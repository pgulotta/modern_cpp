#include <stdio.h>
#include <string>
#include <vector>
#include <type_traits>
#include <algorithm>
#include <set>
#include <cassert>
#include <iostream>
#include "efficient_insert_or_reassign_to_map.hpp"
#include "erase_remove_idiom.hpp"
#include "filter_unique_user_input.hpp"
#include "fold_expressions.hpp"
#include "keep_vector_sorted.hpp"
#include "map_insertion_hint.hpp"
#include "structured_bindings.hpp"
#include "template_class_type_deduction.hpp"
#include "lambda_expressions.hpp"
#include "lambda_combine.hpp"
#include "lambda_multicaller.hpp"
#include "unique_ptr.hpp"
#include "shared_ptr.hpp"
#include "tuple.hpp"
#include "shared_ptr_different_member.hpp"
#include "shared_members.hpp"
#include "shared_from_this.hpp"
#include "optional.hpp"
#include "apply_functions_on_tuples.hpp"
#include "any.hpp"
#include "async.hpp"
//#include "auto_parallel.hpp"
#include "mandelbrot.hpp"
#include "multi_producer_consumer.hpp"
//#include "producer_consumer.hpp"


int main()
{
//  test_fold_expressions();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_template_class_type_deduction();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_structured_bindings();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_efficient_insert_or_reassign_to_map();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_erase_remove_idiom();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_filter_unique_user_input();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_keep_vector_sorted();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_map_insertion_hint();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_lambda_expressions();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_lambda_combine();
//  std::cout << "*************************" << std::endl << std::endl;
//  test_lambda_multicaller();
//  test_unique_ptr();
//  test_shared_ptr();
// test_tuple();
// test_shared_ptr_different_member();
//  test_shared_members();
// test_shared_from_this();
  // test_apply_functions_on_tuples();
// test_optional();
// test_any();
  //test_async();
// test_mandelbrot();
// test_multi_producer_consumer();
// test_producer_consumer();

}
